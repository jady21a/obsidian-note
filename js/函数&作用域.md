就是将一些功能或语句进行**封装**，在需要的时候，通过**调用**的形式，执行这些语句。

## 函数的定义 / 声明
### 方式一：利用函数关键字自定义函数（命名函数）
```
function 函数名([形参1,形参2...形参N]){  // 备注：语法中的中括号，表示“可选”
	语句...
}
```

```
function fun1(a, b){
	return a+b;
}
```
Function ：关键字。函数名 fun1

### 方式二：函数表达式（匿名函数）
```
var 变量名  = function([形参1,形参2...形参N]){
	语句....
}
```

```
var fun2 = function() {
	console.log("我是匿名函数中封装的代码");
};
```
 fun2 是变量名，不是函数名。
 所谓的匿名函数 “函数表达式”，其实就是将匿名函数赋值给一个变量。

### 方式三：使用构造函数 new Function ()

使用构造函数 `new Function()` 来创建一个对象。这种方式，用的少。
```
var fun3 = new Function('a', 'b', 'console.log("我是函数内部的内容");  console.log(a + b);');

fun3(1, 2); // 调用函数
```

## 函数的调用
### 方式 1：普通函数的调用
```
函数名();
```
### 方式 2：通过对象的方法来调用
```
var obj = {
	a: 'qianguyihao',
	fn2: function() {
		console.log('千古壹号，永不止步!');
	},
};

obj.fn2(); // 调用函数
```
###   方式 3：立即执行函数
```
(function() {
	console.log('我是立即执行函数');
})();
```
### 方式 4：通过构造函数来调用
```
function Fun3() {
	console.log('千古壹号，永不止步~');
}

new Fun3();
```
###   方式 5：绑定事件函数
```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <div id="btn">我是按钮，请点击我</div>

        <script>
            var btn = document.getElementById('btn');
            //2.绑定事件
            btn.onclick = function() {
                console.log('点击按钮后，要做的事情');
            };
        </script>
    </body>
</html>
```
### 方式 6：定时器函数
```
    let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
```

## 函数的参数：形参和实参
![[Pasted image 20220311032720.png]]

## 函数的返回值
```
console.log(sum(3, 4)); // 将函数的返回值打印出来

//函数：求和
function sum(a, b) {
	return a + b;
}
```
Return 的作用是结束方法（终止函数）。
-   return 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。

## 函数名、函数体和函数加载问题（重要，请记住）
###   fn () 和 fn 的区别【重要】

-   `fn()`：调用函数。调用之后，还获取了函数的返回值。
    
-   `fn` ：函数对象。相当于直接获取了整个函数对象。

## Break、continue、return 的区别
-   break ：结束当前的循环体（如 for、while）
    
-   continue ：跳出本次循环，继续执行下次循环（如 for、while）
    
-   return ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。

## 方法
**如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法**。
```
	// 调用方法
	obj.fn();
```
## 类数组 arguments   skim

### 作用域（Scope）的概念和分类
作用域是一个变量或函数的作用范围。作用域在**函数定义**时，就已经确定了。
-   **全局作用域**：作用于整个 script 标签内部，或者作用于一个独立的 JS 文件。全局作用域在页面打开时创建，在页面关闭时销毁。
-   **函数作用域**（局部作用域）：作用于函数内的代码环境。

###   作用域的访问关系
在内部作用域中可以访问到外部作用域的变量，在外部作用域中无法访问到内部作用域的变量。

### 变量的作用域
**全局变量**：（比局部变量占内存）
-   在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。
    
-   在全局作用域下，使用 var 声明的变量是全局变量。

**局部变量**：
-   定义在函数作用域的变量，叫「局部变量」。仅限函数内部访问这个变量。
    
-   在函数内部，使用 var 声明的变量是局部变量。
    
-   函数的**形参**也是属于局部变量。

### 变量的声明提前
```
console.log(a);
va[[对象]]r a = 123;
```
打印结果：undefined。变量 a 被提前声明了，只是尚未被赋值
```
console.log(a);
a = 123; //此时a相当于window.a
```
程序报错

既然 JS 中存在变量提升的现象，那么，在实战开发中，为了避免出错，建议先声明一个变量，然后再使用这个变量

### 函数作用域的预处理
、在函数作用域中，也有声明提前的特性：

-   函数中，使用 var 关键字声明的变量，会在函数中所有的代码执行之前被声明。
    
-   函数中，没有 var 声明的变量都是**全局变量**，而且并不会提前声明。

2、定义形参就相当于在函数作用域中声明了变量。

##   预编译前奏
**规律 1：任何变量，如果未经声明就赋值，此变量是属于 window 的属性**，而且不会做变量提升。（注意，无论在哪个作用域内赋值）
**规律 2：一切声明的全局变量，全是 window 的属性**。

Skim 23-32